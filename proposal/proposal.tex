\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[catalan]{babel}
\usepackage[vmargin=3cm]{geometry}
\usepackage{lastpage}
\usepackage{lipsum}
\usepackage{graphicx}
\usepackage{parskip}
\usepackage{listings, listings-rust}     

\graphicspath{ {images/} }

\lstnewenvironment{code}[1][]%
{
   \noindent
   \minipage{\linewidth} 
   \vspace{0.5\baselineskip}
   \lstset{language=Rust, style=colouredRust,#1}}
{\endminipage}

\begin{document}
\begin{titlepage}
	\newcommand{\HRule}{\rule{\linewidth}{0.4mm}} % Defines a new command for horizontal lines, change thickness here
	
	\center

    \vspace*{25px}
    % == Headings ==
	
	\textsc{\LARGE Universitat Autònoma de Barcelona}\\[1.5cm]
	
	\textsc{\Large Treball de Fi de Grau}\\[0.5cm]
	
	\textsc{\Large Informe inicial}\\[0.5cm]
	
	\HRule\\[0.4cm]
	
	{\LARGE\bfseries Disseny i implementació d'un llenguatge de programació amb LLVM}\\[0.4cm]
	
	\HRule\\[1.5cm]
	
	% == Author ==
	
	\begin{minipage}{0.5\textwidth}
		\begin{flushleft}
			\large
			\textit{Autor}\\
			\textsc{Josep Maria Domingo Catafal}
		\end{flushleft}
	\end{minipage}
	~
	\begin{minipage}{0.4\textwidth}
		\begin{flushright}
			\large
			\textit{Tutor}\\
			\textsc{Javier Sánchez Pujadas}
		\end{flushright}
	\end{minipage}
	
	% == Date == 

	\vfill\vfill\vfill % Position the date 3/4 down the remaining page
	
	{\large\today} % Date, change the \today to a set date if you want to be precise

	\vfill % Push the date up 1/4 of the remaining page
\end{titlepage}

% --------------------------------------
% Body
% --------------------------------------
\section{Introducció i el problema a resoldre}
Historicament, generalitzant molt, podem trobar dos tipus de llenguatges: els que 
són ràpids de programar però lents d'executar (ex. Python), i els que són lents 
de programar i ràpids d'executar. En l'última decada han aparegut nous
llenguatges, com ara Go, que intenten situar-se al mig d'aquests dos paradigmes.

\section{Objectiu}
L'objectiu d'aquest treball, és dissenyar i implementar un llenguatge de 
programació que pugui ser executat de forma relativament ràpida, però al mateix 
temps que permeti al programador tenir una expèriencia el més plàcida possible.

Un altre objectiu del llenguatge és intentar minimitzar al màxim els errors que
pot cometre el programador, i per tant reduir el nombre de bugs que es poden
generar en el programa. Per això, serà un llenguatge fortament tipat i inclourà
algunes propietats de llenguatges funcionals com ara la immutabilitat per 
defecte (es pot mutar si el programador vol, però ho ha de fer de forma 
explicita). Si una funció muta l'estat de l'objecte, aquesta ho indicara de 
forma explicita cada cop que es invocada.

Per tal de que el llenguatge permeti un desenvolupament àgil, la gestió de 
memòria serà automàtica.



\section{Metodologia}
Per tal d'organitzar el desenvolupament del projecte, s'han dividit les 
diversers funcionalitats del llenguatge en grans blocs: Un bloc per tenir una 
funcionalitat bàsica i una sèrie de blocs que afegeixen funcionalitat extra.

Cada bloc, conté un seguit de tasques a dins, que definiexen de forma
més granular, que és el que s'ha de desenvolupar.

Per tal de gestionar aquests blocs, és farà servir GitHub, que disposa d'una 
funcionalitat anomenada "Milestones". Aquesta funcionalitat permet crear blocs
de tasques ("milestones")  i posar una data límit a cada bloc. Donat que el 
codi del projecte està allotjat a GitHub, això ens permet enlleçar Pull Requests
amb les tasques, i quan es completa una PR, la tasca es completa automaticament.

Les "milestones" que s'han definit són les següents:

\begin{enumerate}
    \item \textbf{Implementació mínima de l'especificació \null\hfill \textsc{Data límit:} 30 de setembre}\\
        Implementar tota la funcionalitat basica per poder fer programes 
        numerics senzills. Inclou operacions aritmetiques, funcions, control de 
        flux bàsic (if statements i bucles while) i declaració de variables.

    \item \textbf{Type declarations \null\hfill \textsc{Data límit:} 10 d'octubre}\\
        Implementar la funcionalitat necesaria per definir tipus de dades 
        propis (structs, interficies i type aliases).

    \item \textbf{Collections \null\hfill \textsc{Data límit:} 31 d'octubre}\\
        TODO
    
    \item \textbf{Add an error handling mechanism \null\hfill \textsc{Data límit:} 27 de novembre}\\
        TODO
    
    \item \textbf{Syntactic sugar \null\hfill \textsc{Data límit:} 11 de desembre}\\
        Implementació de "Syntactic sugar", per tal de simplificar operacions 
        que s'utilitzen frequentment. Inclou bucles for in, match (similar a un
        switch), list comprehension, etc.
    
    \item \textbf{Support for functional style programming \null\hfill \textsc{Data límit:} 25 de desembre}\\
        TODO
\end{enumerate}

Cada una d'aquestes funcionalitats, generalment, es divideixen en tres 
subtasques principals: implementar el lexer, implementar el parser i 
implementar la generació de codi.

\section{Passos a seguir (planificació)}

\section{Definició del llenguatge}

Per importar llibreries externes s'utilitzen imports

\begin{code}
import math
\end{code}

Podem definir constants globals, però no variables
Amb això es busca evitar comportaments estranys del programa i bugs difícils
de trobar, ja que les variables globals poden ser modificada des de qualsevol
lloc.

\begin{code}
const MAX_SPEED = 120;
\end{code}

El punt d'inici del programa és a la funció main.

\begin{code}
fn main() {
    // Les instruccions acaben sempre amb un punt i coma
    println("Hello World!");
}
\end{code}

Per declarar una funció es fa amb la paraula reservada fn, seguit del nom de la 
funció i els paràmetres entre parèntesis, i finalment el tipus del valor de retorn.
Quan l'última expressió no acaba en punt i coma, el resultat serà el que retornarà
la funció. És l'únic cas en que es permet no posar punt i coma.

\begin{code}
fn radius(circumference: i32) i32 {
    circumference / (2 * math.PI)
}
\end{code}

Podem definir interficies:

\begin{code}
interface person {
    fn change_name(name: string) string;
}
\end{code}

Per crear tipus propis, és fan servir structs. Permeten definir camps de diferents
tipus i definir metodes que modifiquen l'estat de l'objecte. 

Els camps i els mètodes, per defecte són privats, però es poden fer publics.
En el cas de les funcions amb la paraula reservada "pub". En el cas dels camps,
afegin entre claus (\{\}), les paraules get o set, depenent de si volem que sigui publica
per escriptura, lectura o per les dues coses.

Per implementar una interficie, afegim dos punts i el nom de la interficie just 
després del nom del struct.

\begin{code}
struct user : person {
    age: i32 { get, set },
    name: string { get },

    fn change_name(self, name: string) {
        self.name = name;
    }
}
\end{code}

Amb l'struct anterior, podriem per exemple fer el següent:

\begin{code}
let user = user { age: 24, name: "John Doe" };
user.age = 25;
println(user.name);
\end{code}

Però no podriem modificar el camp \textit{name}.

No es obligatori definir constructor, pero si es vol, l'estandard és crear una
funció estatica que es digui "new".

\begin{code}
// constructor
pub fn new(age: i32, name: string) self {
    self {
        age,
        name,
    }
}
\end{code}

Les funcions són estàtiques si no se'l hi passa el parametre self en la primera
posició. Per exemple:

\begin{code}
// static
fn new(age: i32, name: string) self {
    self {
        age,
        name,
    }
}

// non-static
fn change_name(self, name: string) {
    self.name = name;
}
\end{code}

I per cridar-les seria així:

\begin{code}
// static: struct_name::static_fn()
let user = user::new(24, "John Doe");
// non-static: object.fn()
user.change_name("Jane Doe");
\end{code}

Podem definir mètodes fora de la definició del struct. Un cas on seria útil,
per exemple, seria quan treballem amb una entitat amb moltes funcions i volem 
dividir-ho en multiples fitxers.

\begin{code}
pub fn user::get_name() string {
    self.name
}
\end{code}

Quan un mètode muta l'estat d'un objecte, aquesta funció ho ha d'indicar de forma
explicita. Amb això és busca facilitar la vida al programador a l'hora de programar, 
llegir el codi o debugar, ja que només llegint la crida o la definició, sap que
la funció té efectes secundaris.

Per tal d'indicar aquesta mutació, el programador, ha d'afegir la paraula "mut",
a la definició de la funció i cada cop que la crida. 

El mateix passa amb les variables. Per defecte son immutables. Si es mol mutar 
una variable, s'ha d'afegir la paraula "mut".

\begin{code}
pub mut fn set_name(name: string) string {
    self.name = name;
}

fn modify_struct() {
    let mut user = user::new();
    mut user.set_name("new name");
}
\end{code}

\begin{code}
fn loops(numbers: [i32]) {
    let mut b = 0;
    // If statements and for loops don't need parenthesis
    for number in numbers {
        if number % 2 == 0 {
            b += number;
        }
    }

    let mut x = 0;
    // infinite loop
    loop {
        if x > 5 {
            break;
        }
        x += 1; // no ++x or x++ syntax, to avoid confusion
    }

    // Classic for loops can be used for more control
    for let number = 0; number < numbers.len(); number += 1 {
        b += number;
    }

    // Break outer loop from inner loop
    outer: for number in numbers {
        for number in numbers {
            if number % 2 == 0 {
                break outer;
            }
        }
    }
}

fn functional_style(numbers: [i32]) {
    // Functional style with closures
    let numbers_plus_one = numbers.map(|x| -> x + 1);

    let sum = numbers.reduce(|sum, number| -> {
        if number % 2 == 0 {
            sum + number
        }
    });

    let any_greater_than_five = number.any(|x| -> x > 5);
}

fn hash_tables() HashTable(string, user) {
    let hash_table: HashTable(string, user) = {
        "user1": {
            age: 27,
            name: "some_name"
        },
        "user2": {
            "age": 33,
            "name": "some_name2"
        },
    };

    // It can also be declared without type annotations
    let hash_table = {
        "user1": user {
            age: 27,
            name: "some_name"
        },
        "user2": user {
            "age": 33,
            "name": "some_name2"
        },
    };

    // They can be serialized into a JSON string
    let json = hash_table.serialize();

    hash_table
}

// The function will return either a user or an error
fn error_handling() Result<user, key_error> {
    let table = hash_tables();
    // When we access a table, the key may not exist so we need to handle the possible error
    match table.get("user1") {
        Ok(user) => Ok(user),
        Err(e) => Err(e),
    }
    // We don't put a semicolon, so the outcome of match will be returned, either a user or an error
}

// References are immutable by default but we can make them mutable
fn references(numbers: &[i32], other_numbers: &mut [i32]) {
    for number in numbers {
        print(number);
    }

    for number in other_numbers {
        *number += 1; // This will modify the original vector
    }
}
\end{code}

\end{document}
